# Лабораторная №4

## Великий симплекс-метод

Симплекс-метод — алгоритм решения оптимизационной задачи линейного программирования путём перебора вершин выпуклого
многогранника в многомерном пространстве.

Сущность метода: построение базисных решений, на которых монотонно убывает линейный функционал, до ситуации, когда
выполняются необходимые условия локальной оптимальности.

В работе Л. В. Канторовича «Математические методы организации и планирования производства» (1939) были впервые изложены
принципы новой отрасли математики, которая позднее получила название линейного программирования.

Исторически общая задача линейного программирования была впервые поставлена в 1947 году Джорджем Бернардом Данцигом,
Маршаллом Вудом и их сотрудниками в департаменте военно-воздушных сил США. В то время эта группа занималась
исследованием возможности использования математических и смежных с ними методов для военных задач и проблем
планирования. В дальнейшем для развития этих идей в ВВС была организована исследовательская группа под названием Project
SCOOP. Первое успешное решение задачи линейного программирования на ЭВМ SEAC было проведено в январе 1952 года.

Разберём каждый метод в моей реализации более подробно.

### Метод `bOObsMethod`

1. Получение количества ограничений и переменных:

```java
int numConstraints = constraints.getRowDimension();
int numVariables = constraints.getColumnDimension() - 1;
```

`numConstraints` - количество строк в матрице ограничений.
`numVariables` - количество столбцов в матрице ограничений минус один (последний столбец - это столбец свободных
членов).

2. Преобразование задачи минимизации в задачу максимизации:

```java
if(isMinimization){
objective =objective.mapMultiply(-1);
}
```
Если задача является задачей минимизации, умножаем вектор целевой функции на -1.

3. Создание таблицы симплекс-метода:

```java
RealMatrix tableau = new Array2DRowRealMatrix(numConstraints + 1, numVariables + 1);
tableau.setSubMatrix(constraints.getData(), 0, 0);
tableau.setRowVector(numConstraints, objective);
```
Создаем матрицу для симплекс-таблицы размером (количество ограничений + 1) x (количество переменных + 1).
Устанавливаем подматрицу из данных ограничений.
Устанавливаем последнюю строку (целевую функцию).

4. Инициализация массива базисных переменных:

```java
String[] basisVariables = new String[numConstraints];
for (int i = 0; i < numConstraints; i++) {
basisVariables[i] = "x" + (numVariables - numConstraints + i + 1);
}
```
Инициализируем массив базисных переменных с размерами, равными количеству ограничений.
Присваиваем начальные имена базисных переменных.

5. Основной цикл симплекс-метода:

```java
while (true) {
int pivotCol = getPivotColumn(tableau);
if (pivotCol == -1) break;

    int pivotRow = getPivotRow(tableau, pivotCol);
    if (pivotRow == -1) break;

    basisVariables[pivotRow] = "x" + (pivotCol + 1);

    pivotOperation(tableau, pivotRow, pivotCol);

    printTableau(tableau, basisVariables);
}
```
Цикл продолжается до тех пор, пока не найдутся ведущие столбец и строка.
Обновляем базисную переменную и выполняем поворотную операцию.

6. Оптимальное значение целевой функции:

```java
double optimalValue = tableau.getEntry(numConstraints, numVariables);
if (isMinimization) {
optimalValue = -optimalValue;
}
System.out.println("Optimal Value: " + optimalValue);
```
Извлекаем оптимальное значение целевой функции из последней строки и последнего столбца таблицы.
Если задача минимизации, возвращаем значение с правильным знаком.

7. Оптимальные значения переменных:

```java
double[] solution = new double[numVariables];
for (int i = 0; i < numVariables; i++) {
    boolean isBasic = true;
    double value = 0;
    for (int j = 0; j < numConstraints; j++) {
        if (tableau.getEntry(j, i) == 1 && value == 0) {
            value = tableau.getEntry(j, numVariables);
        } else if (tableau.getEntry(j, i) != 0) {
            isBasic = false;
            break;
        }
    }
    solution[i] = isBasic ? value : 0;
}
return solution;
```
Инициализируем массив решений.
Для каждой переменной проверяем, является ли она базисной.
Если переменная базисная, извлекаем значение, иначе устанавливаем значение равным 0.

### Метод `getPivotColumn`

1. Определение последней строки и столбцов:

```java
int lastRow = tableau.getRowDimension() - 1;
int numCols = tableau.getColumnDimension() - 1;
```
Получаем индекс последней строки и количество столбцов, исключая последний столбец (столбец свободных членов).

2. Поиск ведущего столбца:

```java
for (int j = 0; j < numCols; j++) {
    if (tableau.getEntry(lastRow, j) < 0) {
        return j;
    }
}
return -1;
```
Проходим по всем столбцам и ищем отрицательное значение в последней строке.
Возвращаем индекс первого найденного отрицательного элемента.
Если не найдено, возвращаем -1 (оптимальное решение достигнуто).

### Метод `getPivotRow`

Параметры метода `getPivotRow(RealMatrix tableau, int pivotCol)`:

`tableau`: Матрица симплекс-таблицы, содержащая текущие значения переменных и ограничений.

`pivotCol`: Индекс столбца, в котором находится ведущий столбец, выбранный на предыдущем шаге симплекс-метода.

Шаги выполнения:

1. Получаем количество строк в симплекс-таблице за вычетом последней строки, которая содержит коэффициенты целевой функции.
Инициализируем переменную `minRatio` как положительную бесконечность и переменную `pivotRow` как `-1`.
2.  Проходим по всем строкам, кроме последней.
3. Если элемент ведущего столбца положителен, вычисляем отношение соответствующего элемента свободного столбца к элементу ведущего столбца.
4. Если это отношение меньше, чем текущее минимальное отношение, обновляем минимальное отношение и индекс строки `pivotRow`.
5. Возвращаем `pivotRow` в качестве индекса ведущей строки.

### Метод `pivotOperation`

Параметры метода `pivotOperation(RealMatrix tableau, int pivotRow, int pivotCol)`:

Параметры метода:

`tableau`: Матрица симплекс-таблицы, содержащая текущие значения переменных и ограничений.

`pivotRow`: Индекс строки, выбранной как ведущая строка.

`pivotCol`: Индекс столбца, выбранный как ведущий столбец.

Шаги выполнения:

1. Получаем количество строк и столбцов в симплекс-таблице.
2. Получаем значение элемента ведущего столбца, находящегося на пересечении ведущей строки и ведущего столбца.
3. Делим все элементы ведущей строки на значение ведущего элемента, чтобы сделать его равным 1.
4. Для каждой строки, кроме ведущей, вычитаем из неё произведение соответствующего элемента ведущего столбца на элемент ведущей строки, чтобы обнулить этот элемент.
5. Эти шаги обеспечивают корректное выполнение операции поворота в симплекс-методе, направленной на нахождение оптимального решения задачи линейного программирования.